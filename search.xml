<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[24点]]></title>
    <url>%2F2020%2F01%2F10%2F24%E7%82%B9%2F</url>
    <content type="text"><![CDATA[最难忘的游戏大学时代，买入一台组装机，预装了大富翁4，初完颇为兴奋，久完索然乏味。后来室友纷纷推荐，玩了少许新的游戏，最让人沉醉的还是太阁立志传5。那段缤纷绚丽的战国历史犹在眼前，猴子，第六天魔王，独眼龙，风林火山，车悬，无刀取，转，忍犬之术，雷暴之术，村雨，剑圣历历在目。 那些小游戏当我孩子还未长大，我想我会让他熟悉这些小游戏，无论是算数填空，二十一记，还是调制药物，排列茶器，都是值得一试的智力小游戏。我想做一个电脑抑或手机的锁屏游戏，难度随着学历增长吧。啊哈，会成为他的童年乐趣（阴影）吧。 24点我的家人们最喜欢玩的纸牌游戏就是24点了，无论小学生还是研究生，寻找四张牌中的数学奥妙总让人乐此不疲。也许那时就慢慢培养了数学兴趣。 很久就想写下各个小游戏的实现，总是把时间分给了玩游戏，所以做游戏反而不得闲了。后来想也许我得在自己的网站上试试code style。那就小游戏写写吧（玩游戏菜鸟，写游戏亦然）。 表达式穷举123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141public class Point24 &#123; public static void main(String[] args) &#123; calculate(Lists.newArrayList(6, 6, 6, 6)).forEach(System.out::println); System.out.println(); calculate(Lists.newArrayList(1, 2, 1, 7)).forEach(System.out::println); System.out.println(); calculate(Lists.newArrayList(3, 3, 7, 7)).forEach(System.out::println); System.out.println(); calculate(Lists.newArrayList(3, 3, 8, 8)).forEach(System.out::println); System.out.println(); calculate(Lists.newArrayList(1, 5, 5, 5)).forEach(System.out::println); System.out.println(); calculate(Lists.newArrayList(1, 9, 8, 7)).forEach(System.out::println); System.out.println(); &#125; public static Set&lt;String&gt; calculate(List&lt;Integer&gt; numbers) &#123; List&lt;String&gt; opList = new ArrayList&lt;&gt;(); opList.add("+"); opList.add("-"); opList.add("*"); opList.add("/"); List&lt;List&lt;Integer&gt;&gt; numberPerm = Permutation.permutation(numbers); List&lt;List&lt;String&gt;&gt; opSample = Sample.sample(opList, 3); return crossJoin(numberPerm, opSample); &#125; public static Set&lt;String&gt; crossJoin(List&lt;List&lt;Integer&gt;&gt; a, List&lt;List&lt;String&gt;&gt; b) &#123; Set&lt;String&gt; expression = new HashSet&lt;&gt;(); a.forEach(ai -&gt; &#123; b.forEach(bi -&gt; &#123; List&lt;String&gt; result = cal(ai, bi); if (result != null) &#123; expression.addAll(result); &#125; &#125;); &#125;); return expression; &#125; private static List&lt;String&gt; cal(List&lt;Integer&gt; numbers, List&lt;String&gt; ops) &#123; try &#123; List&lt;Exp&gt; exps = numbers.stream().map(i -&gt; new Exp(i.doubleValue())).collect(Collectors.toList()); List&lt;Integer&gt; opIndex = Lists.newArrayList(0, 1, 2); List&lt;List&lt;Integer&gt;&gt; permutation = Permutation.permutation(opIndex); return permutation.stream().map(oi -&gt; &#123; Integer first = oi.get(0); Integer second = oi.get(1); Integer third = oi.get(2); Exp op1 = new Exp(ops.get(first), exps.get(first), exps.get(first + 1)); Exp op2; Exp op3 = new Exp(0.0); if (second - first == 1) &#123; op2 = new Exp(ops.get(second), op1, exps.get(second + 1)); if (third &gt; second) &#123; op3 = new Exp(ops.get(third), op2, exps.get(third + 1)); &#125; else &#123; op3 = new Exp(ops.get(third), exps.get(third), op2); &#125; &#125; else if (second - first == -1) &#123; op2 = new Exp(ops.get(second), exps.get(second), op1); if (third &gt; second) &#123; op3 = new Exp(ops.get(third), op2, exps.get(third + 1)); &#125; else &#123; op3 = new Exp(ops.get(third), exps.get(third), op2); &#125; &#125; else if (second - first == 2) &#123; op2 = new Exp(ops.get(second), exps.get(second), exps.get(second + 1)); op3 = new Exp(ops.get(third), op1, op2); &#125; else if (second - first == -2) &#123; op2 = new Exp(ops.get(second), exps.get(second), exps.get(second + 1)); op3 = new Exp(ops.get(third), op2, op1); &#125; if (Math.abs(op3.value - 24) &lt; 1e-5) &#123; return op3.simpleString(); &#125; return null; &#125;).filter(Objects::nonNull).collect(Collectors.toList()); &#125; catch (Exception e) &#123; &#125; return null; &#125; private static class Exp &#123; private double value; private String exp; public Exp(double value) &#123; this.value = value; this.exp = String.valueOf((int) value); &#125; public Exp(String op, Exp a, Exp b) &#123; value = op(op, a.value, b.value); exp = "(" + a.exp + op + b.exp + ")"; &#125; @Override public String toString() &#123; return exp; &#125; public String simpleString() &#123; if (exp.startsWith("(") &amp;&amp; exp.endsWith(")")) &#123; return exp.substring(1, exp.length() - 1); &#125; else &#123; return exp; &#125; &#125; &#125; private static double op(String op, Double a, Double b) &#123; switch (op) &#123; case "+": return a + b; case "-": return a - b; case "*": return a * b; case "/": return a / b; default: throw new RuntimeException("error op"); &#125; &#125;&#125; 其中有个全排列的类和放回抽样的类，递归是个伟大的发明，它让人类掌握了无穷的力量。 12345678910111213141516171819202122232425262728293031323334353637383940/** * 不放回抽样=全排列 */public class Permutation &#123; public static void main(String[] args) &#123; List&lt;String&gt; abcd = new ArrayList&lt;&gt;(); abcd.add("a"); abcd.add("b"); abcd.add("c"); abcd.add("d"); List&lt;List&lt;String&gt;&gt; result = permutation(abcd); result.forEach(item -&gt; System.out.println(item.stream().collect(Collectors.joining()))); &#125; public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; permutation(List&lt;T&gt; itemList) &#123; List&lt;List&lt;T&gt;&gt; result = new ArrayList&lt;&gt;(); if (itemList.size() == 1) &#123; result.add(itemList); return result; &#125; for (int i = 0; i &lt; itemList.size(); i++) &#123; List&lt;T&gt; otherList = new ArrayList&lt;&gt;(itemList); T first = otherList.remove(i); // 递归公式 p(n)=Σ(0-&gt;n) p1(i)__p(n-i) 其中p(n)返回list&lt;list&gt; p1(i)为返回单元素 __为单元素和list&lt;list&gt;取的逐项拼接逻辑 List&lt;List&lt;T&gt;&gt; otherPermutationResult = permutation(otherList); for (List&lt;T&gt; otherPermutation : otherPermutationResult) &#123; List&lt;T&gt; firstList = new ArrayList&lt;&gt;(); firstList.add(first); firstList.addAll(otherPermutation); result.add(firstList); &#125; &#125; return result; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940/** * 放回抽样 */public class Sample &#123; public static void main(String[] args) &#123; List&lt;String&gt; data = new ArrayList&lt;&gt;(); data.add("a"); data.add("b"); data.add("c"); sample(data, 3).forEach(i -&gt; System.out.println(i.stream().collect(Collectors.joining()))); System.out.println("----"); sample(data, 2).forEach(i -&gt; System.out.println(i.stream().collect(Collectors.joining()))); &#125; public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; sample(List&lt;T&gt; data, int size) &#123; List&lt;List&lt;T&gt;&gt; result = new ArrayList&lt;&gt;(); if (size == 1) &#123; data.forEach(i -&gt; &#123; List&lt;T&gt; item = new ArrayList&lt;&gt;(1); item.add(i); result.add(item); &#125;); return result; &#125; List&lt;List&lt;T&gt;&gt; smallResult = sample(data, size - 1); data.forEach(i -&gt; &#123; smallResult.forEach(s -&gt; &#123; List&lt;T&gt; item = new ArrayList&lt;&gt;(); item.add(i); item.addAll(s); result.add(item); &#125;); &#125;); return result; &#125;&#125; 回溯后来leetcode上给出了一个更为简洁的方案，即从收敛条件看两个数有加减乘除四则运算，其中减除需要交换下，共6种组合。加上除数不能为空判断即可。那么我们的递归逻辑是把大于等于3的数组里面任选2个，转化为1个（四则运算），那么维度降低，知道降低为一维进行求值即可。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神采奕奕]]></title>
    <url>%2F2019%2F03%2F24%2F%E7%A5%9E%E9%87%87%E5%A5%95%E5%A5%95%2F</url>
    <content type="text"><![CDATA[神采奕奕小家伙喜欢吃蛋糕，喜欢跳舞，喜欢跳着走路。小家伙喜欢唱歌，喜欢背诵古诗，喜欢飞快的背诵。小家伙喜欢爬高，喜欢床上打滚，喜欢贴画。小家伙喜欢宝宝巴士，喜欢汪汪队，喜欢巧虎。小家伙偶尔不喜欢斑马英语，常常不喜欢吃感冒药。 神采飞扬小家伙会背诵悯农。小家伙会自我介绍。小家伙会数到10了。小家伙会说好吧好的。小家伙会吹响口琴。]]></content>
      <categories>
        <category>奕</category>
      </categories>
      <tags>
        <tag>奕奕</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素数之恋]]></title>
    <url>%2F2019%2F03%2F24%2F%E7%B4%A0%E6%95%B0%E4%B9%8B%E6%81%8B%2F</url>
    <content type="text"><![CDATA[引子小时候的课程名，是很值得回味的。譬如自然，思想品德，咋一读起，郎朗上口外还有些时间疏离感，仿佛它们只是些美好却又古朴的知识，不如那些一直陪伴，从小学，至中学，甚至大学的基础学科坚守，如语文，数学，物理，化学，过了许多学生时代，它们的名字依然如故。这些名字有着极深的抽象，才能一直简洁的描述这个世界。 物理：格物致理；化学：物各有质，自有变化；数学：九数。这里的九既是九章算术之九，也是数之极，数学本身就是一种无穷的抽象。最近读的就是数论的一角：素数。 素数或者质数，不如说是独数，孤数。整个数字世界中，有效的因子只有自己，也许只有素数才能算独立无二。 论文1859年，伯恩哈德·黎曼（Bernhard Riemann）成为柏林科学院的通讯院士，对于一个青年数学家来说（32岁的黎曼），这是一个崇高的荣誉。依照惯例，黎曼向科学院提交了一篇论文，论文题目是：“论小于一个给定值的素数的个数”。 假设ζ函数的所有非平凡零点的实部都是1/2]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
</search>
